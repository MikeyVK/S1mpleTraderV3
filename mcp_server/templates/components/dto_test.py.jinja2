# {{ test_output_path | default('tests/unit/dtos/strategy/test_' + dto_name.lower() + '.py') }}
"""
Unit tests for {{ dto_name }} DTO.

Tests the {{ description | default(dto_name + ' contract') }} according to TDD principles.
Comprehensive coverage: creation, validation, immutability, edge cases.

@layer: Tests (Unit)
@dependencies: [pytest, pydantic, {{ module_path }}]
"""
# pyright: reportCallIssue=false, reportAttributeAccessIssue=false
# Suppress Pydantic FieldInfo false positives

# Standard library
from datetime import datetime, timezone
from decimal import Decimal

# Third-party
import pytest
from pydantic import ValidationError

# Module under test
from {{ module_path }} import {{ dto_name }}


class Test{{ dto_name }}Creation:
    """Tests for {{ dto_name }} creation and defaults."""

    def test_creation_with_required_fields(self) -> None:
        """Test {{ dto_name }} can be created with only required fields."""
{% if required_fields %}
        dto = {{ dto_name }}(
{% for field in required_fields %}
            {{ field.name }}={{ field.example }},
{% endfor %}
        )
{% for field in required_fields %}
        assert getattr(dto, "{{ field.name }}") == {{ field.example }}
{% endfor %}
{% else %}
        dto = {{ dto_name }}()
        assert dto is not None
{% endif %}

    def test_creation_with_all_fields(self) -> None:
        """Test {{ dto_name }} can be created with all fields."""
        dto = {{ dto_name }}(
{% for field in all_fields %}
            {{ field.name }}={{ field.example }},
{% endfor %}
        )
        assert dto is not None
{% for field in all_fields %}
        assert getattr(dto, "{{ field.name }}") == {{ field.example }}
{% endfor %}

    def test_id_auto_generation(self) -> None:
        """Test {{ dto_name.lower() }}_id is auto-generated if not provided."""
{% if required_fields %}
        dto = {{ dto_name }}(
{% for field in required_fields %}
            {{ field.name }}={{ field.example }},
{% endfor %}
        )
{% else %}
        dto = {{ dto_name }}()
{% endif %}
        dto_id = getattr(dto, "{{ dto_name.lower() }}_id")
        assert dto_id.startswith("{{ id_prefix | default('DTO') }}_")

    def test_custom_id_accepted(self) -> None:
        """Test custom {{ dto_name.lower() }}_id is accepted when valid."""
        custom_id = "{{ id_prefix | default('DTO') }}_20250101_120000_abc123"
        dto = {{ dto_name }}(
            {{ dto_name.lower() }}_id=custom_id,
{% for field in required_fields %}
            {{ field.name }}={{ field.example }},
{% endfor %}
        )
        assert getattr(dto, "{{ dto_name.lower() }}_id") == custom_id


class Test{{ dto_name }}IDValidation:
    """Tests for {{ dto_name.lower() }}_id validation."""

    def test_valid_id_format_accepted(self) -> None:
        """Test valid {{ id_prefix | default('DTO') }}_YYYYMMDD_HHMMSS_hash format is accepted."""
        valid_id = "{{ id_prefix | default('DTO') }}_20250115_143052_a1b2c3"
        dto = {{ dto_name }}(
            {{ dto_name.lower() }}_id=valid_id,
{% for field in required_fields %}
            {{ field.name }}={{ field.example }},
{% endfor %}
        )
        assert getattr(dto, "{{ dto_name.lower() }}_id") == valid_id

    def test_invalid_prefix_rejected(self) -> None:
        """Test ID with wrong prefix is rejected."""
        with pytest.raises(ValidationError) as exc_info:
            {{ dto_name }}(
                {{ dto_name.lower() }}_id="WRONG_20250101_120000_abc123",
{% for field in required_fields %}
                {{ field.name }}={{ field.example }},
{% endfor %}
            )
        assert "{{ dto_name.lower() }}_id" in str(exc_info.value)

    def test_malformed_id_rejected(self) -> None:
        """Test malformed ID format is rejected."""
        with pytest.raises(ValidationError) as exc_info:
            {{ dto_name }}(
                {{ dto_name.lower() }}_id="invalid-format",
{% for field in required_fields %}
                {{ field.name }}={{ field.example }},
{% endfor %}
            )
        assert "{{ dto_name.lower() }}_id" in str(exc_info.value)


{% if has_timestamp %}
class Test{{ dto_name }}TimestampValidation:
    """Tests for timestamp handling."""

    def test_naive_datetime_converted_to_utc(self) -> None:
        """Test naive datetime is automatically converted to UTC."""
        naive_dt = datetime(2025, 1, 15, 12, 0, 0)
        dto = {{ dto_name }}(
            timestamp=naive_dt,
{% for field in required_fields %}
            {{ field.name }}={{ field.example }},
{% endfor %}
        )
        assert dto.timestamp.tzinfo == timezone.utc

    def test_aware_datetime_preserved(self) -> None:
        """Test timezone-aware UTC datetime is preserved."""
        aware_dt = datetime(2025, 1, 15, 12, 0, 0, tzinfo=timezone.utc)
        dto = {{ dto_name }}(
            timestamp=aware_dt,
{% for field in required_fields %}
            {{ field.name }}={{ field.example }},
{% endfor %}
        )
        assert dto.timestamp == aware_dt

    def test_timestamp_auto_generated(self) -> None:
        """Test timestamp is auto-generated as UTC when not provided."""
{% if required_fields %}
        dto = {{ dto_name }}(
{% for field in required_fields %}
            {{ field.name }}={{ field.example }},
{% endfor %}
        )
{% else %}
        dto = {{ dto_name }}()
{% endif %}
        assert dto.timestamp.tzinfo == timezone.utc


{% endif %}
{% for field in validated_fields %}
class Test{{ dto_name }}{{ field.name | title | replace('_', '') }}Validation:
    """Tests for {{ field.name }} field validation."""

    def test_valid_{{ field.name }}_accepted(self) -> None:
        """Test valid {{ field.name }} value is accepted."""
        dto = {{ dto_name }}(
            {{ field.name }}={{ field.valid_example }},
{% for req_field in required_fields if req_field.name != field.name %}
            {{ req_field.name }}={{ req_field.example }},
{% endfor %}
        )
        assert getattr(dto, "{{ field.name }}") == {{ field.valid_example }}

{% if field.invalid_example is defined %}
    def test_invalid_{{ field.name }}_rejected(self) -> None:
        """Test invalid {{ field.name }} value is rejected."""
        with pytest.raises(ValidationError) as exc_info:
            {{ dto_name }}(
                {{ field.name }}={{ field.invalid_example }},
{% for req_field in required_fields if req_field.name != field.name %}
                {{ req_field.name }}={{ req_field.example }},
{% endfor %}
            )
        assert "{{ field.name }}" in str(exc_info.value)

{% endif %}
{% if field.min_value is defined %}
    def test_{{ field.name }}_below_minimum_rejected(self) -> None:
        """Test {{ field.name }} below minimum value is rejected."""
        with pytest.raises(ValidationError) as exc_info:
            {{ dto_name }}(
                {{ field.name }}={{ field.min_value }} - 1,
{% for req_field in required_fields if req_field.name != field.name %}
                {{ req_field.name }}={{ req_field.example }},
{% endfor %}
            )
        assert "{{ field.name }}" in str(exc_info.value)

{% endif %}
{% if field.max_value is defined %}
    def test_{{ field.name }}_above_maximum_rejected(self) -> None:
        """Test {{ field.name }} above maximum value is rejected."""
        with pytest.raises(ValidationError) as exc_info:
            {{ dto_name }}(
                {{ field.name }}={{ field.max_value }} + 1,
{% for req_field in required_fields if req_field.name != field.name %}
                {{ req_field.name }}={{ req_field.example }},
{% endfor %}
            )
        assert "{{ field.name }}" in str(exc_info.value)

{% endif %}

{% endfor %}
{% if frozen | default(true) %}
class Test{{ dto_name }}Immutability:
    """Tests for {{ dto_name }} immutability (frozen=True)."""

    def test_fields_cannot_be_modified(self) -> None:
        """Test that {{ dto_name }} fields cannot be changed after creation."""
{% if required_fields %}
        dto = {{ dto_name }}(
{% for field in required_fields %}
            {{ field.name }}={{ field.example }},
{% endfor %}
        )
{% else %}
        dto = {{ dto_name }}()
{% endif %}
        with pytest.raises(ValidationError):
            dto.{{ dto_name.lower() }}_id = "{{ id_prefix | default('DTO') }}_20250101_999999_new123"

    def test_extra_fields_forbidden(self) -> None:
        """Test that extra fields are forbidden (extra='forbid')."""
        with pytest.raises(ValidationError) as exc_info:
            {{ dto_name }}(
                nonexistent_field="should_fail",
{% for field in required_fields %}
                {{ field.name }}={{ field.example }},
{% endfor %}
            )
        assert "extra" in str(exc_info.value).lower()


{% endif %}
class Test{{ dto_name }}EdgeCases:
    """Tests for {{ dto_name }} edge cases and serialization."""

{% if optional_fields %}
    def test_all_optional_fields_none(self) -> None:
        """Test {{ dto_name }} with all optional fields as None."""
        dto = {{ dto_name }}(
{% for field in required_fields %}
            {{ field.name }}={{ field.example }},
{% endfor %}
        )
{% for field in optional_fields %}
        assert getattr(dto, "{{ field.name }}") is None
{% endfor %}

{% endif %}
    def test_roundtrip_serialization(self) -> None:
        """Test {{ dto_name }} can be serialized and deserialized."""
{% if all_fields %}
        dto = {{ dto_name }}(
{% for field in all_fields %}
            {{ field.name }}={{ field.example }},
{% endfor %}
        )
{% else %}
        dto = {{ dto_name }}()
{% endif %}
        json_data = dto.model_dump_json()
        restored = {{ dto_name }}.model_validate_json(json_data)
        assert restored == dto

    def test_json_schema_examples_valid(self) -> None:
        """Test that json_schema_extra examples are valid {{ dto_name }} instances."""
        schema = {{ dto_name }}.model_json_schema()
        examples = schema.get("examples", [])
        # Examples should exist per coding standards
        assert len(examples) >= 1, "At least one example required"
