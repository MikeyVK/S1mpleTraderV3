{#- worker.py.jinja2 - Concrete template for IWorkerLifecycle workers -#}
{#- Version: 3.2.0 -#}
{#- Purpose: Generate V3 two-phase initialization workers (IWorker + IWorkerLifecycle) -#}
{%- extends "tier2_base_python.jinja2" -%}

{%- import "tier3_pattern_python_async.jinja2" as p_async -%}
{%- import "tier3_pattern_python_lifecycle.jinja2" as lifecycle -%}
{%- import "tier3_pattern_python_error.jinja2" as errors -%}
{%- import "tier3_pattern_python_logging.jinja2" as p_logging -%}
{%- import "tier3_pattern_python_di.jinja2" as di -%}
{%- import "tier3_pattern_python_log_enricher.jinja2" as log_enricher -%}
{%- import "tier3_pattern_python_translator.jinja2" as translator -%}

{#-
TEMPLATE_METADATA:
  enforcement: GUIDELINE
  level: concrete
  artifact_type: worker
  pattern: IWorkerLifecycle
  validates:
    guidelines:
      - "Implements IWorkerLifecycle two-phase initialization"
      - "Uses capabilities DI in initialize()"
      - "Uses LogEnricher for structured logging"
      - "Uses Translator keys for user-facing strings"
  extends: tier2_base_python.jinja2
  purpose: "Worker implementation with IWorkerLifecycle pattern (V3 two-phase initialization)"
  version: "3.2.0"
  changelog:
    - version: "3.2.0"
      date: "2026-02-01"
      changes: "Add optional async warmup example (no unused imports unless enabled)"
  introspection:
    template_id: concrete_worker
    tier: concrete
    parent: tier2_base_python
    variables:
      required:
        - name
        - layer
      optional:
        - module_description
        - worker_scope  # platform|strategy|platform_within_strategy
        - responsibilities
        - capabilities  # List of required capabilities
        - use_async  # If true, scaffold an async warmup example
    pattern: IWorkerLifecycle
    rationale: |
      V3 two-phase initialization pattern:
      1. Construction: __init__(build_spec) - Config only, no dependencies
      2. Runtime init: initialize(strategy_cache, **capabilities) - DI injection
      3. Cleanup: shutdown() - Graceful resource release
-#}

{#- Module docstring customization -#}
{% block module_docstring %}
"""
{{ name }} - {{ module_description | default('Worker implementation') }}.

@layer: {{ layer }}
@dependencies: [backend.core.interfaces, backend.dtos]
@responsibilities:
{% if responsibilities %}
{% for responsibility in responsibilities %}
    - {{ responsibility }}
{% endfor %}
{% else %}
    - [To be defined]
{% endif %}
"""
{% endblock %}

{% block imports_section %}
# Standard library
from __future__ import annotations
from typing import TYPE_CHECKING, Any

{% if use_async | default(false) %}
{{ p_async.pattern_async_imports(include_types=False) }}
{% endif %}

{{ p_logging.pattern_logging_imports() }}

# Third-party
# (Add third-party imports here if needed)

# Project modules
from backend.core.interfaces.worker import IWorker, IWorkerLifecycle, WorkerInitializationError
{{ log_enricher.pattern_log_enricher_imports() }}
{{ translator.pattern_translator_imports() }}

if TYPE_CHECKING:
    from backend.core.interfaces.strategy_cache import IStrategyCache
    from backend.core.interfaces.config import BuildSpec
{% endblock %}

{% block class_structure %}
__all__ = ["{{ name }}"]


class {{ name }}({{- lifecycle.pattern_lifecycle_base_class(include_iworker=true) -}}):
    """
    {{ name }} worker implementation.

    Architecture:
    - EventAdapter-compliant: Standard IWorker + IWorkerLifecycle pattern
    - Worker scope: {{ worker_scope | default('strategy') }}
{% if worker_scope == 'platform' %}
    - Platform worker: Does NOT require strategy_cache (expects None)
{% elif worker_scope == 'platform_within_strategy' %}
    - Platform-within-Strategy: Requires strategy_cache (singleton per strategy)
{% else %}
    - Strategy worker: Requires strategy_cache for runtime state
{% endif %}
{% if capabilities %}
    - Required capabilities: {{ capabilities | join(', ') }}
{% endif %}
    """

    def __init__(self, build_spec: BuildSpec) -> None:
        """
        Construct {{ name }} with configuration.

        V3 Pattern: Construction phase accepts BuildSpec only (no dependencies).
        Dependencies injected via initialize() during runtime initialization.

        Args:
            build_spec: Worker configuration (from manifest.yaml)
        """
        self._name: str = build_spec.name
        self._config = build_spec.config

        {{ lifecycle.pattern_lifecycle_init(cache_attr="_cache") | indent(8) }}

        self.logger: LogEnricher | None = None
        self._translator: Translator | None = None
{% if use_async | default(false) %}
        self._warmup_task: "asyncio.Task[None] | None" = None
{% endif %}

    @property
    def name(self) -> str:
        """Get worker name (IWorker requirement)."""
        return self._name

    def initialize(
        self,
        strategy_cache: IStrategyCache | None = None,
        **capabilities: Any,
    ) -> None:
        """
        Initialize with runtime dependencies.

        V3 Pattern: Runtime initialization phase injects dependencies.
        Platform assembles workers in any order, then calls initialize() with DI.

        Args:
            strategy_cache: StrategyCache instance or None
{% if worker_scope == 'platform' %}
                - Platform worker: Expects None (validates cache is None)
{% elif worker_scope == 'platform_within_strategy' %}
                - Platform-within-Strategy: REQUIRED (validates cache not None)
{% else %}
                - Strategy worker: REQUIRED (validates cache not None)
{% endif %}
            **capabilities: Optional capabilities injected by platform

        Raises:
            WorkerInitializationError: If requirements not met
        """
{% if worker_scope == 'platform' %}
        # Validate strategy_cache is None (Platform worker)
        if strategy_cache is not None:
            raise WorkerInitializationError(
                f"{self._name}: worker.initialize.strategy_cache.unexpected"
            )
{% else %}
        {{ di.pattern_di_require_dependency(dep_name="strategy_cache", worker_name_attr="_name", details="required") | indent(8) }}
{% endif %}

        {{ di.pattern_di_set_dependency(attr_name="_cache", dep_name="strategy_cache") | indent(8) }}

        # Optional: translator can be injected as a capability
        # (fallback behavior is to use keys as display strings)
        if "translator" in capabilities:
            self._translator = capabilities["translator"]

        # Set up structured logger (LogEnricher)
        logger = LogEnricher(logging.getLogger(__name__))
        {{ log_enricher.pattern_log_enricher_set_logger(attr_name="logger") | indent(8) }}
        {{ log_enricher.pattern_log_enricher_setup(message_key="worker.initialize") | indent(8) }}

        {{ translator.pattern_translator_key_guideline() | indent(8) }}

{% if capabilities %}
        # Validate required capabilities
{% for capability in capabilities %}
        {{ di.pattern_di_require_capability(cap_key=capability, worker_name_attr="_name", details="required") | indent(8) }}
{% endfor %}

        # Store required capabilities
{% for capability in capabilities %}
        {{ di.pattern_di_set_capability(attr_name="_" ~ capability, cap_key=capability) | indent(8) }}
{% endfor %}
{% endif %}

{% if use_async | default(false) %}
        # Example: start async warmup if an event loop is running
        try:
            self._warmup_task = asyncio.create_task(self._warmup_async())
        except RuntimeError:
            # No running event loop in this context
            pass

{% endif %}
        # Perform additional initialization here

{% if use_async | default(false) %}
    async def _warmup_async(self) -> None:
        """Async warmup hook."""
        await asyncio.sleep(0)

{% endif %}
    def shutdown(self) -> None:
        """Graceful shutdown and resource cleanup.

        IWorkerLifecycle requirement: Must be idempotent (safe to call multiple times).
        Must complete within 5 seconds and never raise exceptions.
        """
        try:
{% if use_async | default(false) %}
            if self._warmup_task is not None:
                self._warmup_task.cancel()
                self._warmup_task = None
{% endif %}
            self._cache = None
        except Exception:  # noqa: BLE001
            # GUIDELINE: shutdown must not raise; best-effort cleanup only.
            pass
{% endblock %}
