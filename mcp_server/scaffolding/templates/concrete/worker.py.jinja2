{#- worker.py.jinja2 - Concrete template for IWorkerLifecycle workers -#}
{#- Version: 3.0.0 -#}
{#- Purpose: Generate V3 two-phase initialization workers (IWorker + IWorkerLifecycle) -#}
{%- extends "tier2_base_python.jinja2" -%}

{#-
TEMPLATE_METADATA:
  enforcement: STRICT
  level: concrete
  artifact_type: worker
  pattern: IWorkerLifecycle
  validates:
    strict:
      - "class.*\\(IWorker, IWorkerLifecycle\\):"
      - "def __init__\\(self, build_spec: BuildSpec\\)"
      - "def initialize\\(self, strategy_cache.*\\*\\*capabilities\\)"
      - "def shutdown\\(self\\)"
      - "@property"
      - "def name\\(self\\)"
  extends: tier2_base_python.jinja2
  purpose: "Worker implementation with IWorkerLifecycle pattern (V3 two-phase initialization)"
  version: "3.0.0"
  introspection:
    template_id: concrete_worker
    tier: concrete
    parent: tier2_base_python
    variables:
      required:
        - name
        - layer
        - worker_scope  # platform|strategy|platform_within_strategy
        - responsibilities
      optional:
        - module_description
        - capabilities  # List of required capabilities
    pattern: IWorkerLifecycle
    rationale: |
      V3 two-phase initialization pattern:
      1. Construction: __init__(build_spec) - Config only, no dependencies
      2. Runtime init: initialize(strategy_cache, **capabilities) - DI injection
      3. Cleanup: shutdown() - Graceful resource release
      
      Benefits:
      - No circular dependencies (V2 problem)
      - Flexible bootstrap order
      - Testable in isolation
      - Standardized lifecycle
-#}

{#- Module docstring customization -#}
{%- block module_docstring %}
"""
{{ name }} - {{ module_description | default('Worker implementation') }}.

@layer: {{ layer }}
@dependencies: [backend.core.interfaces, backend.dtos]
@responsibilities:
{%- if responsibilities %}
{%- for responsibility in responsibilities %}
    - {{ responsibility }}
{%- endfor %}
{%- else %}
    - [To be defined]
{%- endif %}
"""
{%- endblock %}

{#- Imports section -#}
{%- block imports_section %}
# Standard library
from __future__ import annotations

from typing import TYPE_CHECKING, Any

# Third-party
# (Add third-party imports here if needed)

# Project modules
from backend.core.interfaces.worker import IWorker, IWorkerLifecycle, WorkerInitializationError

if TYPE_CHECKING:
    from backend.core.interfaces.cache import IStrategyCache
    from backend.core.interfaces.config import BuildSpec

{%- endblock %}

{#- Class structure -#}
{%- block class_structure %}

__all__ = ["{{ name }}"]


class {{ name }}(IWorker, IWorkerLifecycle):
    """
    {{ name }} worker implementation.

    Architecture:
    - EventAdapter-compliant: Standard IWorker + IWorkerLifecycle pattern
    - Worker scope: {{ worker_scope | default('strategy') }}
{%- if worker_scope == 'platform' %}
    - Platform worker: Does NOT require strategy_cache (expects None)
{%- elif worker_scope == 'platform_within_strategy' %}
    - Platform-within-Strategy: Requires strategy_cache (singleton per strategy)
{%- else %}
    - Strategy worker: Requires strategy_cache for runtime state
{%- endif %}
{%- if capabilities %}
    - Required capabilities: {{ capabilities | join(', ') }}
{%- endif %}
    """

    def __init__(self, build_spec: BuildSpec) -> None:
        """
        Construct {{ name }} with configuration.

        V3 Pattern: Construction phase accepts BuildSpec only (no dependencies).
        Dependencies injected via initialize() during runtime initialization.

        Args:
            build_spec: Worker configuration (from manifest.yaml)
        """
        self._name: str = build_spec.name
        self._config = build_spec.config
        self._cache: IStrategyCache | None = None
        # Store other initialization state here

    @property
    def name(self) -> str:
        """Get worker name (IWorker requirement)."""
        return self._name

    def initialize(
        self,
        strategy_cache: IStrategyCache | None = None,
        **capabilities: Any,
    ) -> None:
        """
        Initialize with runtime dependencies.

        V3 Pattern: Runtime initialization phase injects dependencies.
        Platform assembles workers in any order, then calls initialize() with DI.

        Args:
            strategy_cache: StrategyCache instance or None
{%- if worker_scope == 'platform' %}
                - Platform worker: Expects None (validates cache is None)
{%- elif worker_scope == 'platform_within_strategy' %}
                - Platform-within-Strategy: REQUIRED (validates cache not None)
{%- else %}
                - Strategy worker: REQUIRED (validates cache not None)
{%- endif %}
            **capabilities: Optional capabilities injected by platform:
{%- if capabilities %}
{%- for capability in capabilities %}
                - {{ capability }}: [Description of capability]
{%- endfor %}
{%- else %}
                - (No capabilities required for this worker)
{%- endif %}

        Raises:
            WorkerInitializationError: If requirements not met
        """
{%- if worker_scope == 'platform' %}
        # Validate strategy_cache is None (Platform worker)
        if strategy_cache is not None:
            raise WorkerInitializationError(
                f"{self._name}: Platform worker must not receive strategy_cache "
                f"(got {type(strategy_cache).__name__})",
            )
{%- elif worker_scope == 'platform_within_strategy' %}
        # Validate strategy_cache is present (Platform-within-Strategy worker)
        if strategy_cache is None:
            raise WorkerInitializationError(
                f"{self._name}: Platform-within-Strategy worker requires strategy_cache",
            )
{%- else %}
        # Validate strategy_cache is present (Strategy worker)
        if strategy_cache is None:
            raise WorkerInitializationError(
                f"{self._name}: Strategy worker requires strategy_cache",
            )
{%- endif %}

{%- if capabilities %}
        # Validate required capabilities
{%- for capability in capabilities %}
        if "{{ capability }}" not in capabilities:
            raise WorkerInitializationError(
                f"{self._name}: Required capability '{{ capability }}' not provided",
            )
{%- endfor %}
{%- endif %}

        # Store dependencies
        self._cache = strategy_cache
{%- if capabilities %}
{%- for capability in capabilities %}
        self._{{ capability }} = capabilities["{{ capability }}"]
{%- endfor %}
{%- endif %}

        # Perform additional initialization here

    def shutdown(self) -> None:
        """
        Graceful shutdown and resource cleanup.

        IWorkerLifecycle requirement: Must be idempotent (safe to call multiple times).
        Must complete within 5 seconds and never raise exceptions.

        Release resources:
        - Close connections
        - Cancel async tasks
        - Flush buffers
        - Clear caches
        """
        # Idempotent implementation - no resources to cleanup yet
        ...

{%- endblock %}
