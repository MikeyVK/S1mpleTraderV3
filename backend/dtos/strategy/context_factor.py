# backend/dtos/strategy/context_factor.py
"""
ContextFactor DTO - Individual context assessment factor.

Represents a single strength or weakness factor detected by a ContextWorker.
Part of the SWOT framework's Strengths/Weaknesses quadrant.

@layer: DTOs (Strategy Output)
@dependencies: [pydantic, backend.core.enums, backend.core.context_factors]
"""

# Standard Library Imports
import re
from typing import Any, Dict, Optional

# Third-Party Imports
from pydantic import BaseModel, Field, field_validator, model_validator

# Our Application Imports
from backend.core.enums import ContextType
from backend.core.context_factors import FactorRegistry


class ContextFactor(BaseModel):
    """
    Individual context factor representing a strength or weakness.

    ContextFactors are generated by ContextWorkers and collected by the
    ContextAggregator into an AggregatedContextAssessment. Each factor
    represents either a strength (positive) or weakness (negative) aspect
    of the current market context.

    **SWOT Quadrant:** Strengths / Weaknesses

    **Key Constraints:**
    - Exactly ONE of strength or weakness must be set (mutually exclusive)
    - Factor type must be registered in FactorRegistry (base or custom)
    - Source context type must be valid ContextType enum
    - Scores are normalized 0.0-1.0

    **Usage Example:**
    ```python
    # Strength factor from regime analysis
    factor = ContextFactor(
        factor_type=BaseFactorType.TRENDING_REGIME.value,
        strength=0.75,
        weakness=None,
        source_plugin="trend_analyzer",
        source_context_type=ContextType.REGIME_CLASSIFICATION.value,
        metadata={"trend_slope": 0.023, "duration_bars": 42}
    )

    # Weakness factor from volatility assessment
    factor = ContextFactor(
        factor_type=BaseFactorType.HIGH_VOLATILITY.value,
        strength=None,
        weakness=0.60,
        source_plugin="volatility_detector",
        source_context_type=ContextType.VOLATILITY_ASSESSMENT.value
    )
    ```

    **Philosophy:**
    The platform provides BaseFactorType enum with 36 standard factors.
    Plugins can register custom factors via FactorRegistry. This hybrid
    approach balances standardization with extensibility - the platform
    is "dumb" (just validates and aggregates), plugins are "smart"
    (provide interpretation and scores).

    Attributes:
        factor_type: Registered factor identifier (UPPER_SNAKE_CASE)
        strength: Strength score 0.0-1.0 (None if this is a weakness)
        weakness: Weakness score 0.0-1.0 (None if this is a strength)
        source_plugin: Plugin name that generated this factor
        source_context_type: ContextType enum value indicating worker category
        metadata: Optional plugin-specific additional context
    """

    factor_type: str = Field(
        ...,
        description="Factor type identifier (must be registered in FactorRegistry)"
    )

    strength: Optional[float] = Field(
        default=None,
        description="Strength score 0.0-1.0 (None if weakness)"
    )

    weakness: Optional[float] = Field(
        default=None,
        description="Weakness score 0.0-1.0 (None if strength)"
    )

    source_plugin: str = Field(
        ...,
        description="Plugin name that generated this factor"
    )

    source_context_type: str = Field(
        ...,
        description="ContextType enum value indicating worker category"
    )

    metadata: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Optional plugin-specific additional context"
    )

    model_config = {
        "frozen": True,  # Immutable after creation
        "extra": "forbid",  # No extra fields allowed
        "str_strip_whitespace": True,
        "json_schema_extra": {
            "examples": [
                {
                    "description": "Strength factor - strong trend confirmation",
                    "factor_type": "TREND_ALIGNMENT",
                    "strength": 0.85,
                    "source_plugin": "trend_analyzer",
                    "source_context_type": "TECHNICAL"
                },
                {
                    "description": "Weakness factor - low liquidity risk",
                    "factor_type": "LIQUIDITY_RISK",
                    "weakness": 0.65,
                    "source_plugin": "risk_monitor",
                    "source_context_type": "RISK",
                    "metadata": {"bid_ask_spread": "0.05%", "depth": "weak"}
                },
                {
                    "description": "Fundamental strength - positive news sentiment",
                    "factor_type": "NEWS_SENTIMENT",
                    "strength": 0.72,
                    "source_plugin": "news_analyzer",
                    "source_context_type": "FUNDAMENTAL",
                    "metadata": {"articles_analyzed": 15, "sentiment_score": 0.72}
                }
            ]
        }
    }

    @field_validator("factor_type")
    @classmethod
    def validate_factor_type(cls, v: str) -> str:
        """Validate factor_type format and registration."""
        if not v:
            raise ValueError("factor_type cannot be empty")

        # Check length
        if len(v) < 3:
            raise ValueError(
                f"factor_type must be at least 3 characters, got: {v}"
            )

        if len(v) > 50:
            raise ValueError(
                f"factor_type must be at most 50 characters, got length {len(v)}"
            )

        # Check format (UPPER_SNAKE_CASE)
        pattern = re.compile(r'^[A-Z][A-Z0-9_]*$')
        if not pattern.match(v):
            raise ValueError(
                f"factor_type must be UPPER_SNAKE_CASE, got: {v}"
            )

        # Check if registered in FactorRegistry
        if not FactorRegistry.is_registered(v):
            raise ValueError(
                f"factor_type '{v}' is not registered in FactorRegistry. "
                f"Use BaseFactorType enum or register custom factor first."
            )

        return v

    @field_validator("strength")
    @classmethod
    def validate_strength(cls, v: Optional[float]) -> Optional[float]:
        """Validate strength is in 0.0-1.0 range if provided."""
        if v is None:
            return v

        if not 0.0 <= v <= 1.0:
            raise ValueError(
                f"strength must be between 0.0 and 1.0, got: {v}"
            )

        return v

    @field_validator("weakness")
    @classmethod
    def validate_weakness(cls, v: Optional[float]) -> Optional[float]:
        """Validate weakness is in 0.0-1.0 range if provided."""
        if v is None:
            return v

        if not 0.0 <= v <= 1.0:
            raise ValueError(
                f"weakness must be between 0.0 and 1.0, got: {v}"
            )

        return v

    @model_validator(mode='after')
    def validate_strength_weakness_mutual_exclusivity(self):
        """Ensure exactly ONE of strength or weakness is set."""
        has_strength = self.strength is not None
        has_weakness = self.weakness is not None

        if has_strength and has_weakness:
            raise ValueError(
                "Cannot set both strength and weakness - they are mutually exclusive. "
                "A factor represents either a strength OR a weakness, not both."
            )

        if not has_strength and not has_weakness:
            raise ValueError(
                "At least one of strength or weakness is required. "
                "A factor must represent either a strength OR a weakness."
            )

        return self

    @field_validator("source_plugin")
    @classmethod
    def validate_source_plugin(cls, v: str) -> str:
        """Validate source_plugin format."""
        if not v:
            raise ValueError("source_plugin cannot be empty")

        # Check length
        if len(v) < 3:
            raise ValueError(
                f"source_plugin must be at least 3 characters, got: {v}"
            )

        if len(v) > 100:
            raise ValueError(
                f"source_plugin must be at most 100 characters, got length {len(v)}"
            )

        # Check format (alphanumeric + underscores)
        pattern = re.compile(r'^[a-zA-Z0-9_]+$')
        if not pattern.match(v):
            raise ValueError(
                f"source_plugin must be alphanumeric with underscores, got: {v}"
            )

        return v

    @field_validator("source_context_type")
    @classmethod
    def validate_source_context_type(cls, v: str) -> str:
        """Validate source_context_type is valid ContextType enum."""
        if not v:
            raise ValueError("source_context_type cannot be empty")

        # Check format (UPPER_SNAKE_CASE)
        pattern = re.compile(r'^[A-Z][A-Z0-9_]*$')
        if not pattern.match(v):
            raise ValueError(
                f"source_context_type must be UPPER_SNAKE_CASE, got: {v}"
            )

        # Check if valid ContextType enum value
        valid_types = [ct.value for ct in ContextType]
        if v not in valid_types:
            raise ValueError(
                f"source_context_type '{v}' is not a valid ContextType. "
                f"Valid types: {', '.join(valid_types)}"
            )

        return v

    @field_validator("metadata")
    @classmethod
    def validate_metadata(cls, v: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """Validate metadata is a dictionary if provided."""
        # Pydantic already enforces Dict type at parse time
        # This validator is a no-op but kept for consistency
        return v
